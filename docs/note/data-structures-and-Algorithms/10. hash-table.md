---
title: 散列表
order: 810
toc: menu
nav:
  title: 笔记
  order: 2
---

# 散列表

## 一、散列表的由来？

1. 散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。
2. 需要存储在散列表中的数据我们称为键，将键转化为数组下标的方法称为散列函数，散列函数的计算结果称为散列值。
3. 将数据存储在散列值对应的数组下标位置。

## 二、如何设计散列函数？

总结 3 点设计散列函数的基本要求

1. 散列函数计算得到的散列值是一个非负整数。
2. 若 key1=key2，则 hash(key1)=hash(key2)
3. 若 key≠key2，则 hash(key1)≠hash(key2)
   正是由于第 3 点要求，所以产生了几乎无法避免的散列冲突问题。

## 三、散列冲突的解放方法？

1. 常用的散列冲突解决方法有 2 类：开放寻址法（open addressing）和链表法（chaining）
2. 开放寻址法
   ① 核心思想：如果出现散列冲突，就重新探测一个空闲位置，将其插入。
   ② 线性探测法（Linear Probing）：
   插入数据：当我们往散列表中插入数据时，如果某个数据经过散列函数之后，存储的位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。
   查找数据：我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素是否相等，若相等，则说明就是我们要查找的元素；否则，就顺序往后依次查找。如果遍历到数组的空闲位置还未找到，就说明要查找的元素并没有在散列表中。
   删除数据：为了不让查找算法失效，可以将删除的元素特殊标记为 deleted，当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。
   结论：最坏时间复杂度为 O(n)
   ③ 二次探测（Quadratic probing）：线性探测每次探测的步长为 1，即在数组中一个一个探测，而二次探测的步长变为原来的平方。
   ④ 双重散列（Double hashing）：使用一组散列函数，直到找到空闲位置为止。
   ⑤ 线性探测法的性能描述：
   用“装载因子”来表示空位多少，公式：散列表装载因子=填入表中的个数/散列表的长度。
   装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。
3. 链表法（更常用）
   插入数据：当插入的时候，我们需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，所以插入的时间复杂度为 O(1)。
   查找或删除数据：当查找、删除一个元素时，通过散列函数计算对应的槽，然后遍历链表查找或删除。对于散列比较均匀的散列函数，链表的节点个数 k=n/m，其中 n 表示散列表中数据的个数，m 表示散列表中槽的个数，所以是时间复杂度为 O(k)。

## 四、思考

1. Word 文档中单词拼写检查功能是如何实现的？
   字符串占用内存大小为 8 字节，20 万单词占用内存大小不超过 20MB，所以用散列表存储 20 万英文词典单词，然后对每个编辑进文档的单词进行查找，若未找到，则提示拼写错误。
2. 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？
   字符串占用内存大小为 8 字节，10 万条 URL 访问日志占用内存不超过 10MB，通过散列表统计 url 访问次数，然后用 TreeMap 存储散列表的元素值（作为 key）和数组下标值（作为 value）
3. 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？
   分别将 2 个数组的字符串通过散列函数映射到散列表，散列表中的元素值为次数。注意，先存储的数组中的相同元素值不进行次数累加。最后，统计散列表中元素值大于等于 2 的散列值对应的字符串就是两个数组中相同的字符串。

## 五、如何设计散列函数？

1. 要尽可能让散列后的值随机且均匀分布，这样会尽可能减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。
2. 除此之外，散列函数的设计也不能太复杂，太复杂就会太耗时间，也会影响到散列表的性能。
3. 常见的散列函数设计方法：直接寻址法、平方取中法、折叠法、随机数法等。

## 六、如何根据装载因子动态扩容？

1. 如何设置装载因子阈值？
   ① 可以通过设置装载因子的阈值来控制是扩容还是缩容，支持动态扩容的散列表，插入数据的时间复杂度使用摊还分析法。
   ② 装载因子的阈值设置需要权衡时间复杂度和空间复杂度。如何权衡？如果内存空间不紧张，对执行效率要求很高，可以降低装载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加装载因子的阈值。
2. 如何避免低效扩容？分批扩容
   ① 分批扩容的插入操作：当有新数据要插入时，我们将数据插入新的散列表，并且从老的散列表中拿出一个数据放入新散列表。每次插入都重复上面的过程。这样插入操作就变得很快了。
   ② 分批扩容的查询操作：先查新散列表，再查老散列表。
   ③ 通过分批扩容的方式，任何情况下，插入一个数据的时间复杂度都是 O(1)。

## 七、如何选择散列冲突解决方法？

① 常见的 2 中方法：开放寻址法和链表法。
② 大部分情况下，链表法更加普适。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如红黑树、跳表，来避免散列表时间复杂度退化成 O(n)，抵御散列冲突攻击。
③ 但是，对于小规模数据、装载因子不高的散列表，比较适合用开放寻址法。

## 八、为什么散列表和链表经常放在一起使用？

1. 散列表的优点：支持高效的数据插入、删除和查找操作
2. 散列表的缺点：不支持快速顺序遍历散列表中的数据
3. 如何按照顺序快速遍历散列表的数据？只能将数据转移到数组，然后排序，最后再遍历数据。
4. 我们知道散列表是动态的数据结构，需要频繁的插入和删除数据，那么每次顺序遍历之前都需要先排序，这势必会造成效率非常低下。
5. 如何解决上面的问题呢？就是将散列表和链表（或跳表）结合起来使用。

## 九、散列表和链表如何组合起来使用？

1. LRU（Least Recently Used）缓存淘汰算法
   1.1. LRU 缓存淘汰算法主要操作有哪些？主要包含 3 个操作：
   ① 往缓存中添加一个数据；
   ② 从缓存中删除一个数据；
   ③ 在缓存中查找一个数据；
   ④ 总结：上面 3 个都涉及到查找。
   1.2. 如何用链表实现 LRU 缓存淘汰算法？
   ① 需要维护一个按照访问时间从大到小的有序排列的链表结构。
   ② 缓冲空间有限，当空间不足需要淘汰一个数据时直接删除链表头部的节点。
   ③ 当要缓存某个数据时，先在链表中查找这个数据。若未找到，则直接将数据放到链表的尾部。若找到，就把它移动到链表尾部。
   ④ 前面说了，LRU 缓存的 3 个主要操作都涉及到查找，若单纯由链表实现，查找的时间复杂度很高为 O(n)。若将链表和散列表结合使用，查找的时间复杂度会降低到 O(1)。
   1.3. 如何使用散列表和链表实现 LRU 缓存淘汰算法？
   ① 使用双向链表存储数据，链表中每个节点存储数据（data）、前驱指针（prev）、后继指针（next）和 hnext 指针（解决散列冲突的链表指针）。
   ② 散列表通过链表法解决散列冲突，所以每个节点都会在两条链中。一条链是双向链表，另一条链是散列表中的拉链。前驱和后继指针是为了将节点串在双向链表中，hnext 指针是为了将节点串在散列表的拉链中。
   ③LRU 缓存淘汰算法的 3 个主要操作如何做到时间复杂度为 O(1)呢？
   首先，我们明确一点就是链表本身插入和删除一个节点的时间复杂度为 O(1)，因为只需更改几个指针指向即可。
   接着，来分析查找操作的时间复杂度。当要查找一个数据时，通过散列表可实现在 O(1)时间复杂度找到该数据，再加上前面说的插入或删除的时间复杂度是 O(1)，所以我们总操作的时间复杂度就是 O(1)。
2. Redis 有序集合
   2.1. 什么是有序集合？
   ① 在有序集合中，每个成员对象有 2 个重要的属性，即 key（键值）和 score（分值）。
   ② 不仅会通过 score 来查找数据，还会通过 key 来查找数据。
   2.2. 有序集合的操作有哪些？
   举个例子，比如用户积分排行榜有这样一个功能：可以通过用户 ID 来查找积分信息，也可以通过积分区间来查找用户 ID。这里用户 ID 就是 key，积分就是 score。所以，有序集合的操作如下：
   ① 添加一个对象；
   ② 根据键值删除一个对象；
   ③ 根据键值查找一个成员对象；
   ④ 根据分值区间查找数据，比如查找积分在[100.356]之间的成员对象；
   ⑤ 按照分值从小到大排序成员变量。
   这时可以按照分值将成员对象组织成跳表结构，按照键值构建一个散列表。那么上面的所有操作都非常高效。
3. Java LinkedHashMap
   和 LRU 缓存淘汰策略实现一模一样。支持按照插入顺序遍历数据，也支持按照访问顺序遍历数据。
