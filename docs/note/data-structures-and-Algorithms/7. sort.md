---
title: 排序
order: 87
toc: menu
nav:
  title: 笔记
  order: 2
---

# 排序

## 一、几种经典排序算法及其时间复杂度级别

冒泡、插入、选择 O(n^2) 基于比较
快排、归并 O(nlogn) 基于比较
计数、基数、桶 O(n) 不基于比较

## 二、如何分析一个排序算法？

1. 学习排序算法的思路？明确原理、掌握实现以及分析性能。
2. 如何分析排序算法性能？从执行效率、内存消耗以及稳定性 3 个方面分析排序算法的性能。
3. 执行效率：从以下 3 个方面来衡量
   - 最好情况、最坏情况、平均情况时间复杂度
   - 时间复杂度的系数、常数、低阶：排序的数据量比较小时考虑
   - 比较次数和交换（或移动）次数
4. 内存消耗：通过空间复杂度来衡量。针对排序算法的空间复杂度，引入原地排序的概念，原地排序算法就是指空间复杂度为 O(1)的排序算法。
5. 稳定性：如果待排序的序列中存在值等的元素，经过排序之后，相等元素之间原有的先后顺序不变，就说明这个排序算法时稳定的。

## 三、冒泡排序

1. 排序原理
   - 冒泡排序只会操作相邻的两个数据。
   - 对相邻两个数据进行比较，看是否满足大小关系要求，若不满足让它俩互换。
   - 一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。
   - 优化：若某次冒泡不存在数据交换，则说明已经达到完全有序，所以终止冒泡。
2. 代码实现（见下一条留言）
3. 性能分析 - 执行效率：最小时间复杂度、最大时间复杂度、平均时间复杂度
   最小时间复杂度：数据完全有序时，只需进行一次冒泡操作即可，时间复杂度是 O(n)。
   最大时间复杂度：数据倒序排序时，需要 n 次冒泡操作，时间复杂度是 O(n^2)。
   平均时间复杂度：通过有序度和逆序度来分析。
   什么是有序度？
   有序度是数组中具有有序关系的元素对的个数，比如[2,4,3,1,5,6]这组数据的有序度就是 11，分别是[2,4][2,3][2,5][2,6][4,5][4,6][3,5][3,6][1,5][1,6][5,6]。同理，对于一个倒序数组，比如[6,5,4,3,2,1]，有序度是 0；对于一个完全有序的数组，比如[1,2,3,4,5,6]，有序度为 n*(n-1)/2，也就是 15，完全有序的情况称为满有序度。
   什么是逆序度？逆序度的定义正好和有序度相反。核心公式：逆序度=满有序度-有序度。
   排序过程，就是有序度增加，逆序度减少的过程，最后达到满有序度，就说明排序完成了。
   冒泡排序包含两个操作原子，即比较和交换，每交换一次，有序度加 1。不管算法如何改进，交换的次数总是确定的，即逆序度。
   对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏的情况初始有序度为 0，所以要进行 n*(n-1)/2 交换。最好情况下，初始状态有序度是 n*(n-1)/2，就不需要进行交互。我们可以取个中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。
   换句话说，平均情况下，需要 n\*(n-1)/4 次交换操作，比较操作可定比交换操作多，而复杂度的上限是 O(n^2)，所以平均情况时间复杂度就是 O(n^2)。
   以上的分析并不严格，但很实用，这就够了。 - 空间复杂度：每次交换仅需 1 个临时变量，故空间复杂度为 O(1)，是原地排序算法。 - 算法稳定性：如果两个值相等，就不会交换位置，故是稳定排序算法。

## 四、插入排序

1. 算法原理
   首先，我们将数组中的数据分为 2 个区间，即已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想就是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间中的元素一直有序。重复这个过程，直到未排序中元素为空，算法结束。
2. 代码实现（见下一条留言）
3. 性能分析 - 时间复杂度：最好、最坏、平均情况
   如果要排序的数组已经是有序的，我们并不需要搬移任何数据。只需要遍历一遍数组即可，所以时间复杂度是 O(n)。如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，因此时间复杂度是 O(n^2)。而在一个数组中插入一个元素的平均时间复杂都是 O(n)，插入排序需要 n 次插入，所以平均时间复杂度是 O(n^2)。 - 空间复杂度：从上面的代码可以看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，是原地排序算法。 - 算法稳定性：在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现的元素的后面，这样就保持原有的顺序不变，所以是稳定的。

## 五、选择排序

1. 算法原理
   选择排序算法也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，并将其放置到已排序区间的末尾。
2. 代码实现（见下一条留言）
3. 性能分析
   1）时间复杂度：最好、最坏、平均情况
   选择排序的最好、最坏、平均情况时间复杂度都是 O(n^2)。为什么？因为无论是否有序，每个循环都会完整执行，没得商量。
   2）空间复杂度：
   选择排序算法空间复杂度是 O(1)，是一种原地排序算法。
   3）算法稳定性：
   选择排序算法不是一种稳定排序算法，比如[5,8,5,2,9]这个数组，使用选择排序算法第一次找到的最小元素就是 2，与第一个位置的元素 5 交换位置，那第一个 5 和中间的 5 的顺序就变量，所以就不稳定了。正因如此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。

## 六、分治思想

1. 分治思想：分治，顾明思意，就是分而治之，将一个大问题分解成小的子问题来解决，小的子问题解决了，大问题也就解决了。
2. 分治与递归的区别：分治算法一般都用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧。

## 七、归并排序

1. 算法原理
   先把数组从中间分成前后两部分，然后对前后两部分分别进行排序，再将排序好的两部分合并到一起，这样整个数组就有序了。这就是归并排序的核心思想。如何用递归实现归并排序呢？写递归代码的技巧就是分写得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。递推公式怎么写？如下
   递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))
   终止条件：p >= r 不用再继续分解
2. 代码实现
3. 性能分析
   1）算法稳定性：
   归并排序稳不稳定关键要看 merge()函数，也就是两个子数组合并成一个有序数组的那部分代码。在合并的过程中，如果 A[p…q] 和 A[q+1…r] 之间有值相同的元素，那我们就可以像伪代码中那样，先把 A[p…q] 中的元素放入 tmp 数组，这样 就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一种稳定排序算法。
   2）时间复杂度：分析归并排序的时间复杂度就是分析递归代码的时间复杂度
   如何分析递归代码的时间复杂度？
   递归的适用场景是一个问题 a 可以分解为多个子问题 b、c，那求解问题 a 就可以分解为求解问题 b、c。问题 b、c 解决之后，我们再把 b、c 的结果合并成 a 的结果。若定义求解问题 a 的时间是 T(a)，则求解问题 b、c 的时间分别是 T(b)和 T(c)，那就可以得到这样的递推公式：T(a) = T(b) + T(c) + K，其中 K 等于将两个子问题 b、c 的结果合并成问题 a 的结果所消耗的时间。这里有一个重要的结论：不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。套用这个公式，那么归并排序的时间复杂度就可以表示为：
   T(1) = C； n=1 时，只需要常量级的执行时间，所以表示为 C。
   T(n) = 2*T(n/2) + n； n>1，其中 n 就是 merge()函数合并两个子数组的的时间复杂度 O(n)。
   T(n) = 2*T(n/2) + n
   = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
   = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
   = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
   ......
   = 2^k _ T(n/2^k) + k _ n
   ......
   当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到 k=log2n。将 k 带入上面的公式就得到 T(n)=Cn+nlog2n。如用大 O 表示法，T(n)就等于 O(nlogn)。所以，归并排序的是复杂度时间复杂度就是 O(nlogn)。
   3）空间复杂度：归并排序算法不是原地排序算法，空间复杂度是 O(n)
   为什么？因为归并排序的合并函数，在合并两个数组为一个有序数组时，需要借助额外的存储空间。为什么空间复杂度是 O(n)而不是 O(nlogn)呢？如果我们按照分析递归的时间复杂度的方法，通过递推公式来求解，那整个归并过程需要的空间复杂度就是 O(nlogn)，但这种分析思路是有问题的！因为，在实际上，递归代码的空间复杂度并不是像时间复杂度那样累加，而是这样的过程，即在每次合并过程中都需要申请额外的内存空间，但是合并完成后，临时开辟的内存空间就被释放掉了，在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时空间再大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。

## 八、快速排序

1. 算法原理
   快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。然后遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 povit 放到中间。经过这一步之后，数组 p 到 r 之间的数据就分成了 3 部分，前面 p 到 q-1 之间都是小于 povit 的，中间是 povit，后面的 q+1 到 r 之间是大于 povit 的。根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。
   递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)
   终止条件：p >= r
2. 代码实现
3. 性能分析
   1）算法稳定性：
   因为分区过程中涉及交换操作，如果数组中有两个 8，其中一个是 pivot，经过分区处理后，后面的 8 就有可能放到了另一个 8 的前面，先后顺序就颠倒了，所以快速排序是不稳定的排序算法。比如数组[1,2,3,9,8,11,8]，取后面的 8 作为 pivot，那么分区后就会将后面的 8 与 9 进行交换。
   2）时间复杂度：最好、最坏、平均情况
   快排也是用递归实现的，所以时间复杂度也可以用递推公式表示。
   如果每次分区操作都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并的相同。
   T(1) = C； n=1 时，只需要常量级的执行时间，所以表示为 C。
   T(n) = 2\*T(n/2) + n； n>1
   所以，快排的时间复杂度也是 O(nlogn)。
   如果数组中的元素原来已经有序了，比如 1，3，5，6，8，若每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的，需要进行大约 n 次的分区，才能完成整个快排过程，而每次分区我们平均要扫描大约 n/2 个元素，这种情况下，快排的时间复杂度就是 O(n^2)。
   前面两种情况，一个是分区及其均衡，一个是分区极不均衡，它们分别对应了快排的最好情况时间复杂度和最坏情况时间复杂度。那快排的平均时间复杂度是多少呢？T(n)大部分情况下是 O(nlogn)，只有在极端情况下才是退化到 O(n^2)，而且我们也有很多方法将这个概率降低。
   3）空间复杂度：快排是一种原地排序算法，空间复杂度是 O(1)

## 九、归并排序与快速排序的区别

归并和快排用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？

1. 归并排序，是先递归调用，再进行合并，合并的时候进行数据的交换。所以它是自下而上的排序方式。何为自下而上？就是先解决子问题，再解决父问题。
2. 快速排序，是先分区，在递归调用，分区的时候进行数据的交换。所以它是自上而下的排序方式。何为自上而下？就是先解决父问题，再解决子问题。

## 十、线性排序算法介绍

1. 线性排序算法包括桶排序、计数排序、基数排序。
2. 线性排序算法的时间复杂度为 O(n)。
3. 此 3 种排序算法都不涉及元素之间的比较操作，是非基于比较的排序算法。
4. 对排序数据的要求很苛刻，重点掌握此 3 种排序算法的适用场景。

## 十一、桶排序（Bucket sort）

1. 算法原理：
   1）将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序。
   2）桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。
2. 使用条件
   1）要排序的数据需要很容易就能划分成 m 个桶，并且桶与桶之间有着天然的大小顺序。
   2）数据在各个桶之间分布是均匀的。
3. 适用场景
   1）桶排序比较适合用在外部排序中。
   2）外部排序就是数据存储在外部磁盘且数据量大，但内存有限无法将整个数据全部加载到内存中。
4. 应用案例
   1）需求描述：
   有 10GB 的订单数据，需按订单金额（假设金额都是正整数）进行排序
   但内存有限，仅几百 MB
   2）解决思路：
   扫描一遍文件，看订单金额所处数据范围，比如 1 元-10 万元，那么就分 100 个桶。
   第一个桶存储金额 1-1000 元之内的订单，第二个桶存 1001-2000 元之内的订单，依次类推。
   每个桶对应一个文件，并按照金额范围的大小顺序编号命名（00，01，02，…，99）。
   将 100 个小文件依次放入内存并用快排排序。
   所有文件排好序后，只需按照文件编号从小到大依次读取每个小文件并写到大文件中即可。
   3）注意点：若单个文件无法全部载入内存，则针对该文件继续按照前面的思路进行处理即可。

## 十二、计数排序（Counting sort）

1. 算法原理
   1）计数其实就是桶排序的一种特殊情况。
   2）当要排序的 n 个数据所处范围并不大时，比如最大值为 k，则分成 k 个桶
   3）每个桶内的数据值都是相同的，就省掉了桶内排序的时间。
2. 代码实现
   案例分析：
   假设只有 8 个考生分数在 0-5 分之间，成绩存于数组 A[8] = [2，5，3，0，2，3，0，3]。
   使用大小为 6 的数组 C[6]表示桶，下标对应分数，即 0，1，2，3，4，5。
   C[6]存储的是考生人数，只需遍历一边考生分数，就可以得到 C[6] = [2，0，2，3，0，1]。
   对 C[6]数组顺序求和则 C[6]=[2，2，4，7，7，8]，c[k]存储的是小于等于分数 k 的考生个数。
   数组 R[8] = [0，0，2，2，3，3，3，5]存储考生名次。那么如何得到 R[8]的呢？
   从后到前依次扫描数组 A，比如扫描到 3 时，可以从数组 C 中取出下标为 3 的值 7，也就是说，到目前为止，包括自己在内，分数小于等于 3 的考生有 7 个，也就是说 3 是数组 R 的第 7 个元素（也就是数组 R 中下标为 6 的位置）。当 3 放入数组 R 后，小于等于 3 的元素就剩下 6 个了，相应的 C[3]要减 1 变成 6。
   以此类推，当扫描到第二个分数为 3 的考生时，就会把它放入数组 R 中第 6 个元素的位置（也就是下标为 5 的位置）。当扫描完数组 A 后，数组 R 内的数据就是按照分数从小到大排列的了。
3. 使用条件
   1）只能用在数据范围不大的场景中，若数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序；
   2）计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数；
   3）比如如果考试成绩精确到小数后一位，就需要将所有分数乘以 10，转换为整数。

## 十三、基数排序（Radix sort）

1. 算法原理（以排序 10 万个手机号为例来说明）
   1）比较两个手机号码 a，b 的大小，如果在前面几位中 a 已经比 b 大了，那后面几位就不用看了。
   2）借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序。
   3）经过 11 次排序后，手机号码就变为有序的了。
   4）每次排序有序数据范围较小，可以使用桶排序或计数排序来完成。
2. 使用条件
   1）要求数据可以分割独立的“位”来比较；
   2）位之间由递进关系，如果 a 数据的高位比 b 数据大，那么剩下的地位就不用比较了；
   3）每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到 O(n)。

## 十四、如何选择合适的排序算法？

1. 排序算法一览表
   时间复杂度 是稳定排序？ 是原地排序？
   冒泡排序 O(n^2) 是 是
   插入排序 O(n^2) 是 是
   选择排序 O(n^2) 否 是
   快速排序 O(nlogn) 否 是
   归并排序 O(nlogn) 是 否
   桶排序 O(n) 是 否
   计数排序 O(n+k)，k 是数据范围 是 否
   基数排序 O(dn)，d 是纬度 是 否
2. 为什选择快速排序？
   1）线性排序时间复杂度很低但使用场景特殊，如果要写一个通用排序函数，不能选择线性排序。
   2）为了兼顾任意规模数据的排序，一般会首选时间复杂度为 O(nlogn)的排序算法来实现排序函数。
   3）同为 O(nlogn)的快排和归并排序相比，归并排序不是原地排序算法，所以最优的选择是快排。

## 十五、如何优化快速排序？

导致快排时间复杂度降为 O(n)的原因是分区点选择不合理，最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。如何优化分区点的选择？有 2 种常用方法，如下：

1. 三数取中法
   ① 从区间的首、中、尾分别取一个数，然后比较大小，取中间值作为分区点。
   ② 如果要排序的数组比较大，那“三数取中”可能就不够用了，可能要“5 数取中”或者“10 数取中”。
2. 随机法：每次从要排序的区间中，随机选择一个元素作为分区点。
3. 警惕快排的递归发生堆栈溢出，有 2 中解决方法，如下：
   ① 限制递归深度，一旦递归超过了设置的阈值就停止递归。
   ② 在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈过程，这样就没有系统栈大小的限制。

## 十六、通用排序函数实现技巧

1. 数据量不大时，可以采取用时间换空间的思路
2. 数据量大时，优化快排分区点的选择
3. 防止堆栈溢出，可以选择在堆上手动模拟调用栈解决
4. 在排序区间中，当元素个数小于某个常数是，可以考虑使用 O(n^2)级别的插入排序
5. 用哨兵简化代码，每次排序都减少一次判断，尽可能把性能优化到极致
