---
title: 二分查找
order: 88
toc: menu
nav:
  title: 笔记
  order: 2
---

# 二分查找

## 一、什么是二分查找？

二分查找针对的是一个有序的数据集合，每次通过跟区间中间的元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间缩小为 0。

## 二、时间复杂度分析？

1. 时间复杂度
   假设数据大小是 n，每次查找后数据都会缩小为原来的一半，最坏的情况下，直到查找区间被缩小为空，才停止。所以，每次查找的数据大小是：n，n/2，n/4，…，n/(2^k)，…，这是一个等比数列。当 n/(2^k)=1 时，k 的值就是总共缩小的次数，也是查找的总次数。而每次缩小操作只涉及两个数据的大小比较，所以，经过 k 次区间缩小操作，时间复杂度就是 O(k)。通过 n/(2^k)=1，可求得 k=log2n，所以时间复杂度是 O(logn)。
2. 认识 O(logn)
   ① 这是一种极其高效的时间复杂度，有时甚至比 O(1)的算法还要高效。为什么？
   ② 因为 logn 是一个非常“恐怖“的数量级，即便 n 非常大，对应的 logn 也很小。比如 n 等于 2 的 32 次方，也就是 42 亿，而 logn 才 32。
   ③ 由此可见，O(logn)有时就是比 O(1000)，O(10000)快很多。

## 三、如何实现二分查找？

1. 循环实现
   代码实现：

```javascript
public int binarySearch1(int[] a, int val){
  int start = 0;
  int end = a.length - 1;
  while(start <= end){
    int mid = start + (end - start) / 2;
    if(a[mid] > val) end = mid - 1;
    else if(a[mid] < val) start = mid + 1;
    else return mid;
  }
  return -1;
}
```

注意事项：
① 循环退出条件是：start<=end，而不是 start<end。
② mid 的取值，使用 mid=start + (end - start) / 2，而不用 mid=(start + end)/2，因为如果 start 和 end 比较大的话，求和可能会发生 int 类型的值超出最大范围。为了把性能优化到极致，可以将除以 2 转换成位运算，即 start + ((end - start) >> 1)，因为相比除法运算来说，计算机处理位运算要快得多。
③start 和 end 的更新：start = mid - 1，end = mid + 1，若直接写成 start = mid，end=mid，就可能会发生死循环。

2. 递归实现

```javascript
public int binarySearch(int[] a, int val){
  return bSear(a, val, 0, a.length-1);
}
private int bSear(int[] a, int val, int start, int end) {
  if(start > end) return -1;
  int mid = start + (end - start) / 2;
  if(a[mid] == val) return mid;
  else if(a[mid] > val) end = mid - 1;
  else start = mid + 1;
  return bSear(a, val, start, end);
}
```

## 四、使用条件（应用场景的局限性）

1. 二分查找依赖的是顺序表结构，即数组。
2. 二分查找针对的是有序数据，因此只能用在插入、删除操作不频繁，一次排序多次查找的场景中。
3. 数据量太小不适合二分查找，与直接遍历相比效率提升不明显。但有一个例外，就是数据之间的比较操作非常费时，比如数组中存储的都是长度超过 300 的字符串，那这是还是尽量减少比较操作使用二分查找吧。
4. 数据量太大也不是适合用二分查找，因为数组需要连续的空间，若数据量太大，往往找不到存储如此大规模数据的连续内存空间。

## 五、四种常见的二分查找变形问题

1. 查找第一个值等于给定值的元素
2. 查找最后一个值等于给定值的元素
3. 查找第一个大于等于给定值的元素
4. 查找最后一个小于等于给定值的元素

## 六、适用性分析

1. 凡事能用二分查找解决的，绝大部分我们更倾向于用散列表或者二叉查找树，即便二分查找在内存上更节省，但是毕竟内存如此紧缺的情况并不多。
2. 求“值等于给定值”的二分查找确实不怎么用到，二分查找更适合用在”近似“查找问题上。比如上面讲几种变体。

## 七、思考

1. 如何在 1000 万个整数中快速查找某个整数？
   ① 1000 万个整数占用存储空间为 40MB，占用空间不大，所以可以全部加载到内存中进行处理；
   ② 用一个 1000 万个元素的数组存储，然后使用快排进行升序排序，时间复杂度为 O(nlogn)
   ③ 在有序数组中使用二分查找算法进行查找，时间复杂度为 O(logn)
2. 如何编程实现“求一个数的平方根”？要求精确到小数点后 6 位？
3. 如何快速定位出一个 IP 地址的归属地？
   [202.102.133.0, 202.102.133.255] 山东东营市
   [202.102.135.0, 202.102.136.255] 山东烟台
   [202.102.156.34, 202.102.157.255] 山东青岛
   [202.102.48.0, 202.102.48.255] 江苏宿迁
   [202.102.49.15, 202.102.51.251] 江苏泰州
   [202.102.56.0, 202.102.56.255] 江苏连云港
   假设我们有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个 IP 地址的归属地呢？
4. 如果有一个有序循环数组，比如 4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法？
